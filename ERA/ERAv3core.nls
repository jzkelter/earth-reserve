;; patches run this procedure for background ecological degradation
to core.eco-degradation
  ask patches with [ecological-health > 1][ ;; something that asymptotes, use a function instead of linear
      set ecological-health (ecological-health - 1)
      set pcolor scale-color ([color] of one-of CENTRALIZED-OPS-NODES with [node-jurisdiction = [jurisdiction] of myself]) ecological-health -200 300
    ]
end

;; project investors run this procedure to document the characteristics of the potential project (if there is one)
;; if there isn't one they move to a new place (randomly for now)
to core.look-for-new-project
  let bankruptcy-line 100
  if cash >= bankruptcy-line [
    set potential-project core.best-deal-near-me
    ifelse potential-project != nobody [     
      move-to table:get potential-project "project-location"
      ask table:get potential-project "project-location" [
        set proj-here? true
      ]
    ][
      set heading random 360 ;; change to systematic search at some point
      fd (10 + random 10)
    ]
  ]
end

;; project investors try to find the best potential project from a subset of project locations
to-report core.best-deal-near-me
  let max-eco-health-for-proj 1000 ;; arbitrary for now, if health is greater than this number, the patch will not be considered for a project
  let potential-projects patches in-radius 7 with [proj-here? = false 
                                                   and ecological-health < max-eco-health-for-proj
                                                   and ecological-health < calculate-optimal-health [ability] of myself]

  ;; now find the most profitable project based on new method (formulas)
  let proj-investor-ability [ability] of self
  let potential-project-patch max-one-of potential-projects [calculate-estimated-profit (ecological-health) (calculate-optimal-health [ability] of myself) (proj-investor-ability)]
  
  let potential-project-rent-improvement 0
  let potential-project-cost 0
  let potential-project-profit 0
  let potential-project-goal-eco-health 0
  
  if potential-project-patch != nobody [
    set potential-project-rent-improvement calculate-estimated-aiv ([ecological-health] of potential-project-patch) (calculate-optimal-health [ability] of self)
    set potential-project-cost calculate-estimated-cost ([ecological-health] of potential-project-patch) (calculate-optimal-health [ability] of self) (proj-investor-ability)
    set potential-project-profit (potential-project-rent-improvement - potential-project-cost)
    set potential-project-goal-eco-health calculate-optimal-health [ability] of self
  ]
  
  ;; if the project investor cannot afford raising the health all the way to optimal, they do the same project but just invest everything they have
  if potential-project-cost > [cash] of self [
    set potential-project-cost [cash] of self
    let new-eco-health-given-max-investment sqrt((2 * [ability] of self * c1 * potential-project-cost) - c2 ^ 2) - c2
    set potential-project-rent-improvement calculate-estimated-aiv ([ecological-health] of potential-project-patch) new-eco-health-given-max-investment
    set potential-project-profit (potential-project-rent-improvement - potential-project-cost)
    set potential-project-goal-eco-health new-eco-health-given-max-investment
  ]
  
  let min-return-wanted 0.1 ;; saying project investors want a 10% return on their investment based on their estimates
  
  ifelse potential-project-patch != nobody 
  and potential-project-rent-improvement >= NODE-MIN-PROJECT-SIZE 
  and potential-project-cost <= [cash] of self  ;; probably don't need this again, given check above
  and potential-project-profit >= potential-project-cost * min-return-wanted [
    
    let potential-project-table table:make
    table:put potential-project-table "project-location" potential-project-patch
    table:put potential-project-table "current-eco-health" [ecological-health] of potential-project-patch
    table:put potential-project-table "project-investor-estimated-aiv" potential-project-rent-improvement
    table:put potential-project-table "project-cost" potential-project-cost
    table:put potential-project-table "project-timeframe" round ((potential-project-rent-improvement) / 10) + 1
    table:put potential-project-table "goal-eco-health" potential-project-goal-eco-health
    
    report potential-project-table
  ][
    report nobody
  ]
end

;; randomness here reflects uncertanties/different beliefs in estimation
to-report calculate-estimated-aiv [old-eco-health new-eco-health]
  report random-normal (calculate-rent new-eco-health - calculate-rent old-eco-health) ((calculate-rent new-eco-health - calculate-rent old-eco-health) / 5)
end

to-report calculate-estimated-cost [old-eco-health new-eco-health proj-investor-ability]
  report calculate-investment new-eco-health proj-investor-ability - calculate-investment old-eco-health proj-investor-ability
end

to-report calculate-estimated-profit [old-eco-health new-eco-health proj-investor-ability]
  report calculate-estimated-aiv old-eco-health new-eco-health - calculate-estimated-cost old-eco-health new-eco-health proj-investor-ability
end

to-report calculate-rent [eco-health]
  report c0 * ln(eco-health)
end

to-report calculate-investment [eco-health proj-investor-ability] ;; investment needed to get from 0 health to (eco-health) level
  report ((eco-health ^ 2) / (2 * proj-investor-ability * c1)) + ((c2 * eco-health) / (proj-investor-ability * c1))
end

to-report calculate-optimal-health [proj-investor-ability]
  report (- c2 + sqrt (c2 ^ 2 + (4 * proj-investor-ability * c0 * c1))) / 2
end



;; project investors run this procedure to set a minimum aiv they are willing to tolerate
;; to be used in their decision making during proposal to the node later
to core.select-min-redemption-price
  let cost table:get potential-project "project-cost"
  ;; where the COST stuff comes in, same as selecting price there
  let min-return 1.1
  let min-redemption-price cost * min-return
  table:put potential-project "min-redemption-price" min-redemption-price
end

;; project investors run this procedure to choose which operations node they want to transact with
;; right now it's assumed the only possibilities are only that of their home country or a decentralized one
to core.choose-ops-node
  let prob-choose-home-ops-node 80 ;; arbitrary for now
  ifelse random 100 < prob-choose-home-ops-node [ ;; instead of random for later, include prediction of relative worth of currencies
    let proj-ops-node one-of CENTRALIZED-OPS-NODES with [node-jurisdiction = [home-jurisdiction] of myself]
    table:put potential-project "relevant-ops-node" proj-ops-node
    ask proj-ops-node [
      set proj-investors-with-new-projects-for-me fput myself proj-investors-with-new-projects-for-me
    ]
  ][
    let proj-ops-node one-of DECENTRALIZED-OPS-NODES
    table:put potential-project "relevant-ops-node" proj-ops-node
    ask proj-ops-node [
      set proj-investors-with-new-projects-for-me fput myself proj-investors-with-new-projects-for-me
    ]
  ]
end

;; operations nodes run this procedure to assess the proposal of project investors who come to them
;; within this procedure they estimate their own aiv of the proposed project
to core.review-proposals
  let relevant-project-investors turtle-set [proj-investors-with-new-projects-for-me] of self

  ask relevant-project-investors [
    table:put potential-project "do-project?" false
    core.node-accept-or-reject potential-project
  ]
end

;; operations nodes run this procedure to make a decision on their proposal assessment
to core.node-accept-or-reject [potential-project-table]
  
  let min-redemption-price table:get potential-project-table "min-redemption-price"
  let proj-investor-estimated-aiv table:get potential-project-table "project-investor-estimated-aiv"
  let node-estimated-aiv round (random-normal proj-investor-estimated-aiv (proj-investor-estimated-aiv / 7)) ;; assumes the estimation is more or less the same
 
  ifelse node-estimated-aiv < NODE-MIN-PROJECT-SIZE [ ;; potential project was already filtered for it, but there's a chance the node estimation is lower
      table:put potential-project "proposal-result" "reject"
    ][ 
      table:put potential-project "proposal-result" "accept"
    ]
  
  if table:get potential-project "proposal-result" = "accept" and node-estimated-aiv >= min-redemption-price [
      core.proj-investor-accept node-estimated-aiv
    ]
end

;; operations node run this procedure to update the current project list of project investors 
;; if they accept the project and the project investor goes through with it
to core.proj-investor-accept [node-estimated-aiv]
  table:put potential-project "node-estimated-aiv" node-estimated-aiv
  table:put potential-project "do-project?" true
end

;; project investors run this procedure to update project information each tick
to core.update-project-info
  if potential-project != nobody and table:get potential-project "do-project?" = false [
      ;; ask patch to set proj-here false if project investor decided to not do project
      ask table:get potential-project "project-location" [
        set proj-here? false
      ]
    ]
  if potential-project != nobody and table:get potential-project "do-project?" = true [
      set cash (cash - table:get potential-project "project-cost")
      table:put potential-project "project-time-elapsed" 0
      set current-projects fput potential-project current-projects
    ]
  ask ops-nodes [
    set proj-investors-with-new-projects-for-me (list)
  ]
end

;; project investors run this procedure to keep track of progress of their current projects
to core.update-or-complete-project
  let to-delete (list)
  
  foreach current-projects [ proj -> 
    let time-now table:get proj "project-time-elapsed"
    set time-now (time-now + 1)
    table:put proj "project-time-elapsed" time-now ;; can also be a reporter to get diff in time
    
    if table:get proj "project-time-elapsed" = table:get proj "project-timeframe" [
      set completed-projects (completed-projects + 1)
      set to-delete fput proj to-delete
    ]
  ]
  
  foreach to-delete [ proj ->
    core.complete-project-and-get-deposit-receipt proj
    core.update-patch-stats proj
    set current-projects remove proj current-projects
  ]
  
  set potential-project (list)
end


;; project investors run this procedure to get their deposit receipt (and check if they want to cash in immediately)
;; the project investors also update their variables like abilty and cash (where applicable)
to core.complete-project-and-get-deposit-receipt [project] ;; project is a TABLE now
  let old-redemption-price-node table:get project "node-estimated-aiv"
  let old-redemption-price-proj-investor table:get project "project-investor-estimated-aiv"
  ;; the project gets reassessed at completion
  let reviewed-redemption-price-node round (random-normal old-redemption-price-node (old-redemption-price-node / 6))
  let reviewed-redemption-price-proj-investor round (random-normal old-redemption-price-proj-investor (old-redemption-price-proj-investor / 6))

  let new-deposit-receipt table:make
  table:put new-deposit-receipt "first-node-estimated-aiv" reviewed-redemption-price-node
  table:put new-deposit-receipt "first-project-investor-estimated-aiv" reviewed-redemption-price-proj-investor
  
  ifelse reviewed-redemption-price-node >= reviewed-redemption-price-proj-investor [ ;; proj investor would want to cash in immediately
    set cash (cash + reviewed-redemption-price-node)
  ][ ;; proj investor would want to hold on to the deposit receipt as a financial security, time to decide price to set in the market
    set deposit-receipts fput new-deposit-receipt deposit-receipts
  ]

  ;; determine the rest of the stream using time series from COST code

  ;; update project investor ability
  if ability < 1 [
    set ability (ability + 0.01)]
end

;; project investors run this procedure to update (completed) project location ecological health
to core.update-patch-stats [project]
  let finished-project-location table:get project "project-location"
  let finished-project-goal-eco-health table:get project "goal-eco-health"
  ask finished-project-location [
    set ecological-health finished-project-goal-eco-health
    set proj-counter (proj-counter + 1)
    set proj-here? false
    set pcolor scale-color ([color] of min-one-of CENTRALIZED-OPS-NODES [distance myself]) ecological-health -200 300
  ]
end