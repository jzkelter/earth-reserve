to ERi.recalculate-exchange-rates
;; the observer runs this procedure
  foreach table:keys CURRENT-EXCHANGE-RATES [ currency-name ->
    let base-rate table:get BASE-YEAR-EXCHANGE-RATES currency-name ;; 1 c0 = base-rate (currency of interest)
    let ERiC-ref table:get ERiCs "c0" ;; because exchange rate information is in terms of c0, can be made more robust later depending on global ref currency?
    let ERiC-target table:get ERiCs currency-name
    
    let multiplier (ERiC-ref / ERiC-target)
    let new-rate precision (base-rate * multiplier) 4
    table:put CURRENT-EXCHANGE-RATES currency-name new-rate
  ]
end


to-report convert-currency [origin-currency target-currency amount-in-origin-currency] ;; currencies should be their names like "c0" or "d0" 
  let origin-currency-relative table:get current-exchange-rates origin-currency
  let target-currency-relative table:get current-exchange-rates target-currency
  ;; origin-currency-relative = target-currency-relative
  
  let relevant-exchange-rate (target-currency-relative / origin-currency-relative)
  report (amount-in-origin-currency * relevant-exchange-rate)
end


to subtract-from-cash-holdings [origin-currency amount-to-subtract] ;; origin currency is now name like "c0"
;; project investors run this procedure
  let origin-currency-held table:get cash origin-currency
  
  let amount-left-to-subtract 0

  ifelse amount-to-subtract <= origin-currency-held [
    let new-origin-currency-held (origin-currency-held - amount-to-subtract)
    table:put cash origin-currency new-origin-currency-held
  ][
    let new-origin-currency-held 0 ;; subtract the origin currency all the way
    table:put cash origin-currency new-origin-currency-held
    set amount-left-to-subtract (amount-to-subtract - origin-currency-held)
  ]

  let cash-table-copy copy-table cash
  table:remove cash-table-copy origin-currency
  
  let cash-holdings-no-origin-currency shuffle (table:keys cash-table-copy) ;; can be better prioritized and sorted to have non zero entries first

  if amount-left-to-subtract > 0 [

    foreach cash-holdings-no-origin-currency [ entry ->
      let cash-held-in-currency table:get cash entry
      let amount-left-to-subtract-in-currency precision (convert-currency origin-currency entry amount-left-to-subtract) 2
        
      if amount-left-to-subtract > 0 [
        ifelse amount-left-to-subtract-in-currency <= cash-held-in-currency [ ;; just subtract from current currency
          let new-currency-held (cash-held-in-currency - amount-left-to-subtract-in-currency)
          table:put cash entry new-currency-held
          set amount-left-to-subtract 0
        ][
          let new-currency-held 0
          table:put cash entry new-currency-held
          ;; need to convert amount left back to origin currency
          set amount-left-to-subtract precision (convert-currency entry origin-currency (amount-left-to-subtract-in-currency - cash-held-in-currency)) 2
        ]
      ]
    ]
  ]
end

to add-to-cash-holdings [currency amount-to-add] ;; currency will need to be currency name like "c0"
  let current-holding-in-currency table:get cash currency
  table:put cash currency (current-holding-in-currency + amount-to-add)
end