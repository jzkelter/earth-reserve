to ERi.recalculate-exchange-rates
  
  ask ops-nodes [
    let id [who] of self
    set CURRENCY-VALUES replace-item id CURRENCY-VALUES [ERiC] of one-of ops-nodes with [who = id] ;;theres only one, ignore the one-of used to grab the only ops-node
  ]
  let base-exchange-rates (list)
  let exch-rate table:make
  foreach range (num-jurisdictions + num-decentralized-currencies) [ row ->
    foreach range (num-jurisdictions + num-decentralized-currencies) [ column ->
      let exchange item 0 [ERiC] of ops-nodes with [who = column] / item 0 [ERiC] of ops-nodes with [who = row]  ;; aka how much currency (column) is valued in terms of currency (row)
      table:put exch-rate column exchange
    ]
    set base-exchange-rates lput (copy-table exch-rate) base-exchange-rates
  ]
  ifelse BASE-YEAR-EXCHANGE-RATES = 0[ ;defined at 0 at initialization
    set BASE-YEAR-EXCHANGE-RATES base-exchange-rates
  ] [
    set CURRENT-EXCHANGE-RATES base-exchange-rates
  ]
end


to ERi.recalculate-ERiE ;called by observer
  let new-ERiE table:make
  let soil-health-table table:make
  foreach range num-ecoregions [ eco ->
    let eco-name (ERi.index-to-ecoregion eco)
    let curr-soil-health min (list 1 ((mean [soil-health] of patches with [ecoregion = eco-name] - max-soil-health / 2) / max-soil-health / 2)) ;;normalizes worst case to -1 and best case to 1
    table:put soil-health-table eco-name curr-soil-health
    table:put new-ERiE eco-name (Bezier (curr-soil-health) 0 1)
  ]
  set PREVIOUS-SOIL-HEALTH soil-health-table
  set ERiE new-ERiE
end

to ERi.recalculate-ERiC ;called by ops-nodes
  let eric-temp 0
  ;; we want decentralized ERiC equal to the mean of all other ERiC (we currently lack currency of transaction data, so we assume decentralized is equally responsible for ecoregion change)
  ifelse node-jurisdiction = "decentralized" [
    ask CENTRALIZED-OPS-NODES [
      set eric-temp eric-temp + (ERiC / num-jurisdictions)
    ]
  ] [
    foreach range num-ecoregions [ eco ->
      let eco-name (ERi.index-to-ecoregion eco)
      set eric-temp eric-temp + ((table:get ERiE eco-name) * (ecoregion-percent-of-jurisdiction eco-name who))
    ]
  ]
  set ERiC eric-temp    
end

to-report ecoregion-percent-of-jurisdiction [eco jur]
  if count patches with [jurisdiction = jur] = 0 [report 0] ;; this is a catch all for decentralized op-node and op-nodes with no patches
  report count patches with [Ecoregion = eco and jurisdiction = jur] / count patches with [jurisdiction = jur]
end

to-report Bezier [unadjusted-erie lower-bound upper-bound] ;https://javascript.info/bezier-curve inputs the soil health and outputs the ERiE
  ;numbers currently hardcoded but we can change that later with sliders
  if unadjusted-erie >= 1 [report 0.3]
  if unadjusted-erie <= -1 [report 10]
  
  let t ((upper-bound - lower-bound) / 2) + lower-bound
  (ifelse precision (Bezier-function t) 2 = precision unadjusted-erie 2 [
    report 0.3 * (1 - t) ^ 3 + 3 * (1 - t) ^ 2 * t + 0.15 * (1 - t) * t ^ 2 + 10 * t ^ 3           ;inverse Bezier function to "unwravel" the calculation for t 
  ]  (Bezier-function t) > unadjusted-erie [ 
    report (Bezier unadjusted-erie t upper-bound)
  ]  [
    report (Bezier unadjusted-erie lower-bound t)
  ])
    
  
end

to-report Bezier-function [t]
  report ((1 - t) ^ 3 + 0.2 * (1 - t) ^ 2 * t + -3 * (1 - t) * t ^ 2 + -1 * t ^ 3)
end

to-report ERi.index-to-ecoregion [index]
  report (item index "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
end

to-report convert-currency [origin-currency target-currency amount-in-origin-currency] ;; currencies should be numbers corresponding the "who" of the ops-nodes
  let origin-currency-index origin-currency
  let target-currency-index target-currency 
  let current-exchange-rates-in-origin table:to-list item origin-currency-index CURRENT-EXCHANGE-RATES
  let relevant-exchange-rate last item target-currency-index current-exchange-rates-in-origin ;; 1 unit origin = X units target
  report (amount-in-origin-currency * relevant-exchange-rate)
end


to subtract-from-cash-holdings [origin-currency amount-to-subtract] ;; origin-currency is the currency amount-to-subtract is expressed in currently
  let cash-holdings-list table:to-list cash ;; [["currency-name" amount-held][...][...][...]]
  let origin-currency-held last item origin-currency cash-holdings-list
  let origin-currency-key item origin-currency table:keys cash

  let amount-left-to-subtract 0

  ifelse amount-to-subtract <= origin-currency-held [
    let new-origin-currency-held (origin-currency-held - amount-to-subtract)
    table:put cash origin-currency-key new-origin-currency-held
  ][
    let new-origin-currency-held 0 ;; subtract the origin currency all the way
    table:put cash origin-currency-key new-origin-currency-held
    set amount-left-to-subtract (amount-to-subtract - origin-currency-held)
  ]

  let cash-holdings-no-origin-currency shuffle (remove-item origin-currency cash-holdings-list) ;; can be better prioritized and sorted to have non zero entries first

  if amount-left-to-subtract > 0 [

    foreach cash-holdings-no-origin-currency [ entry ->
      let currency-name first entry
      let cash-held-in-currency last entry
      let currency-index 3 ;; this is for "other"
      ;; need to convert currency so need to get index of the current currency being looped on
      ;; if currency-name != "other" [set currency-index read-from-string currency-name]
      let relevant-currency-key item currency-index table:keys cash
      let amount-left-to-subtract-in-currency precision (convert-currency origin-currency currency-index amount-left-to-subtract) 2

      if amount-left-to-subtract > 0 [
        ifelse amount-left-to-subtract-in-currency <= cash-held-in-currency [
          let new-currency-held (cash-held-in-currency - amount-left-to-subtract-in-currency)
          table:put cash relevant-currency-key new-currency-held
          set amount-left-to-subtract 0
        ][
          let new-currency-held 0
          table:put cash relevant-currency-key new-currency-held
          ;; need to convert amount left back to origin currency
          set amount-left-to-subtract precision (convert-currency currency-index origin-currency (amount-left-to-subtract-in-currency - cash-held-in-currency)) 2
        ]
      ]
    ]
  ]
end

to add-to-cash-holdings [currency amount-to-add]
  let currency-index currency
  if currency-index = "other" or currency-index = "decentralized" [ set currency-index 3 ]
  let cash-holdings-list table:to-list cash
  let relevant-key item currency-index table:keys cash
  let current-holding-in-currency table:get cash relevant-key
  table:put cash relevant-key (current-holding-in-currency + amount-to-add)
end