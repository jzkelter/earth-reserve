to ERi.recalculate-exchange-rates
;  show BASE-YEAR-EXCHANGE-RATES
;  let original-base-year-exchange-rates BASE-YEAR-EXCHANGE-RATES
  let i (list 0 1 2 3)
  let ERiC-list table:to-list ERiC ;; [["currency" ERiC][...][...][...]]
  ;; first foreach loops over sets of exchange rates (so the set of reference currencies)
  foreach i [ index ->
    let base-exchange-rates-table item index BASE-YEAR-EXCHANGE-RATES
    let base-exchange-rates-list table:to-list base-exchange-rates-table ;; [["target currency" exchange rate][...][...][...]]
    let ERiC-ref last (item index ERiC-list) ;; one number, ERiC of reference currency
    let new-exchange-rates-list (list)
  ;; second foreach loops over individual exchange rates within a set
    let index-counter 0
    foreach base-exchange-rates-list [ entry ->
      let currency-name first entry
      let base-rate last entry ;; 1 reference currency = (base-rate) target currency
      let ERiC-target last (item index-counter ERiC-list)
      let multiplier (ERiC-ref / ERiC-target)
      let new-rate precision (base-rate * multiplier) 4
      table:put item index CURRENT-EXCHANGE-RATES currency-name new-rate
      set index-counter (index-counter + 1)
    ]
  ]
;  show CURRENT-EXCHANGE-RATES
;  set BASE-YEAR-EXCHANGE-RATES original-base-year-exchange-rates
end

to ERi.recalculate-ERiE ;called by observer
  let new-ERiE table:make
  let soil-health-table table:make
  let eco 0
  let curr-soil-health 0
  let curr-eco "A"
  while [eco < num-ecoregions] [
    set curr-eco (index-to-ecoregion eco)
    ifelse count patches with [ecoregion = curr-eco] = 0 [
      set curr-soil-health 0
    ]  [
      set curr-soil-health (mean [soil-health] of patches with [ecoregion = curr-eco] / 200)
    ]
    table:put soil-health-table curr-eco curr-soil-health
    table:put new-ERiE curr-eco (Bezier ((table:get PREVIOUS-SOIL-HEALTH curr-eco)- curr-soil-health) 0 1)
    set eco eco + 1
  ]
  set PREVIOUS-SOIL-HEALTH soil-health-table
  set ERiE new-ERiE
end

to ERi.recalculate-ERiC ;called by ops-nodes
  let eco 0
  let eric-temp 0
  while [eco < num-ecoregions] [
    set eric-temp eric-temp + ((table:get ERiE (index-to-ecoregion eco)) * (ecoregion-percent (index-to-ecoregion eco) who))
    set eco eco + 1
  ]
  set ERiC eric-temp
end

to-report ecoregion-percent [eco jur]
  if count patches with [jurisdiction = jur] = 0 [report 0] ;; this is a catch all for decentralized op-node and op-nodes with no patches
  report count patches with [Ecoregion = eco and jurisdiction = jur] / count patches with [jurisdiction = jur]
end

to-report Bezier [unadjusted-erie lower-bound upper-bound] ;https://javascript.info/bezier-curve
  ;numbers currently hardcoded but we can change that later with sliders
  if unadjusted-erie >= 1 [report 0.3]
  if unadjusted-erie <= -1 [report 10]
  
;  let t 0
;  while [ (1 - t) ^ 3 + 0.2 * (1 - t) ^ 2 * t + -3 * (1 - t) * t ^ 2 + -1 * t ^ 3 > unadjusted-erie] [
;    set t t + 0.01
;  ]
;  report 0.3 * (1 - t) ^ 3 + 3 * (1 - t) ^ 2 * t + 0.15 * (1 - t) * t ^ 2 + 10 * t ^ 3
;  
  let t ((upper-bound - lower-bound) / 2) + lower-bound
  (ifelse precision ((1 - t) ^ 3 + 0.2 * (1 - t) ^ 2 * t + -3 * (1 - t) * t ^ 2 + -1 * t ^ 3) 2 = precision unadjusted-erie 2 [
    report 0.3 * (1 - t) ^ 3 + 3 * (1 - t) ^ 2 * t + 0.15 * (1 - t) * t ^ 2 + 10 * t ^ 3
  ]  (1 - t) ^ 3 + 0.2 * (1 - t) ^ 2 * t + -3 * (1 - t) * t ^ 2 + -1 * t ^ 3 > unadjusted-erie [ 
    report (Bezier unadjusted-erie t upper-bound)
  ]  [
    report (Bezier unadjusted-erie lower-bound t)
  ])
    
  
end


to-report index-to-ecoregion [index]
  report (item index "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
end

to-report convert-currency [origin-currency target-currency amount-in-origin-currency] ;; currencies should be numbers corresponding the "who" of the ops-nodes
  let origin-currency-index origin-currency
  let target-currency-index target-currency 
  if origin-currency-index = "decentralized" [set origin-currency-index 3]
  if target-currency-index = "decentralized" [set target-currency-index 3]
  let current-exchange-rates-in-origin table:to-list item origin-currency-index CURRENT-EXCHANGE-RATES
  let relevant-exchange-rate last item target-currency-index current-exchange-rates-in-origin ;; 1 unit origin = X units target
  report (amount-in-origin-currency * relevant-exchange-rate)
end


to subtract-from-cash-holdings [origin-currency amount-to-subtract] ;; origin-currency is the currency amount-to-subtract is expressed in currently
  let cash-holdings-list table:to-list cash ;; [["currency-name" amount-held][...][...][...]]
  let origin-currency-held last item origin-currency cash-holdings-list
  let origin-currency-key item origin-currency table:keys cash

  let amount-left-to-subtract 0

  ifelse amount-to-subtract <= origin-currency-held [
    let new-origin-currency-held (origin-currency-held - amount-to-subtract)
    table:put cash origin-currency-key new-origin-currency-held
  ][
    let new-origin-currency-held 0 ;; subtract the origin currency all the way
    table:put cash origin-currency-key new-origin-currency-held
    set amount-left-to-subtract (amount-to-subtract - origin-currency-held)
  ]

  let cash-holdings-no-origin-currency shuffle (remove-item origin-currency cash-holdings-list) ;; can be better prioritized and sorted to have non zero entries first

  if amount-left-to-subtract > 0 [

    foreach cash-holdings-no-origin-currency [ entry ->
      let currency-name first entry
      let cash-held-in-currency last entry
      let currency-index 3 ;; this is for "other"
      ;; need to convert currency so need to get index of the current currency being looped on
      ;; if currency-name != "other" [set currency-index read-from-string currency-name]
      let relevant-currency-key item currency-index table:keys cash
      let amount-left-to-subtract-in-currency precision (convert-currency origin-currency currency-index amount-left-to-subtract) 2

      if amount-left-to-subtract > 0 [
        ifelse amount-left-to-subtract-in-currency <= cash-held-in-currency [
          let new-currency-held (cash-held-in-currency - amount-left-to-subtract-in-currency)
          table:put cash relevant-currency-key new-currency-held
          set amount-left-to-subtract 0
        ][
          let new-currency-held 0
          table:put cash relevant-currency-key new-currency-held
          ;; need to convert amount left back to origin currency
          set amount-left-to-subtract precision (convert-currency currency-index origin-currency (amount-left-to-subtract-in-currency - cash-held-in-currency)) 2
        ]
      ]
    ]
  ]
end

to add-to-cash-holdings [currency amount-to-add]
  let currency-index currency
  if currency-index = "other" or currency-index = "decentralized" [ set currency-index 3 ]
  let cash-holdings-list table:to-list cash
  let relevant-key item currency-index table:keys cash
  let current-holding-in-currency table:get cash relevant-key
  table:put cash relevant-key (current-holding-in-currency + amount-to-add)
end