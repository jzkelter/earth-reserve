to core.eco-degradation
  ask patches with [ecological-health > 1][ ;; something that asymptotes, use a function instead of linear
      set ecological-health (ecological-health - 1)
      set pcolor ([color] of one-of ops-nodes with [who = [country] of myself] + (sqrt (ecological-health)) / 20)
    ]
    ask patches with [proj-here? = false] [
      set true-eco-benefit-from-proj round (random-normal 300 40 * timeframe-of-proj - ln(ecological-health))
    ]
end

to core.look-for-new-project
  if cash >= 100 [
    let potential-project best-deal-near-me ([ability] of self)
    ifelse potential-project != nobody [
      let new-project table:make
      table:put new-project "project-location" potential-project
      table:put new-project "project-cost" [cost-of-proj] of potential-project
      table:put new-project "project-timeframe" [timeframe-of-proj] of potential-project
      table:put new-project "project-true-eco-benefit" [true-eco-benefit-from-proj] of potential-project
      table:put new-project "project-investor-estimated-aiv" estimated-aiv-potential-project

      set current-projects fput new-project current-projects
      move-to table:get new-project "project-location"
      set new-project? true
      ask table:get new-project "project-location" [
        set proj-here? true
      ]
    ][
      set heading random 360 ;; systematic search at some point
      fd (10 + random 10)
    ]
  ]
end

to core.select-min-redemption-price
  let cost table:get item 0 current-projects "project-cost"
  let time table:get item 0 current-projects "project-timeframe"
  let estimated-aiv table:get item 0 current-projects "project-investor-estimated-aiv"
  ;; where the COST stuff comes in, same as selecting price there
  let min-redemption-price cost + (0.1 * cost)
  table:put item 0 current-projects "min-redemption-price" min-redemption-price
end

to core.choose-ops-node
  ifelse random 100 < 80 [ ;; instead of random for later, include prediction of relative worth of currencies
    let proj-ops-node one-of ops-nodes with [who = [home-country] of myself]
    table:put item 0 current-projects "relevant-ops-node" proj-ops-node
  ][
    let proj-ops-node one-of ops-nodes with [who > count proj-investors]
    table:put item 0 current-projects "relevant-ops-node" proj-ops-node
  ]
end

to core.review-proposals
  let agents-with-new-proposals-for-me proj-investors with [new-project? = true and table:get item 0 current-projects "relevant-ops-node" = myself]

  ask agents-with-new-proposals-for-me [
    let min-redemption-price table:get item 0 current-projects "min-redemption-price"
    let cost table:get item 0 current-projects "project-cost"
    let true-eco-benefit table:get item 0 current-projects "project-true-eco-benefit"
    let time table:get item 0 current-projects "project-timeframe"
    let current-ecological-health [ecological-health] of table:get item 0 current-projects "project-location"
    
    let node-estimated-aiv round (random-normal true-eco-benefit true-eco-benefit / 4)
    
    core.node-accept-or-reject node-estimated-aiv time current-ecological-health
    table:put item 0 current-projects "do-project?" false
        
    if table:get item 0 current-projects "proposal-result" = "accept" [
      if node-estimated-aiv >= min-redemption-price [
        core.accept-project node-estimated-aiv
      ]
    ]
  ]
end

to core.node-accept-or-reject [node-estimated-aiv time current-ecological-health]
  (ifelse current-ecological-health <= 100 [
      table:put item 0 current-projects "proposal-result" "accept"
    ] node-estimated-aiv / time < 150 [
      table:put item 0 current-projects "proposal-result" "reject"
    ][ ;; else
      table:put item 0 current-projects "proposal-result" "accept"
    ]
  )
end

to core.accept-project [node-estimated-aiv]
  table:put item 0 current-projects "node-estimated-aiv" node-estimated-aiv
  table:put item 0 current-projects "do-project?" true
end

to core.update-project-info
    if new-project? = true and table:get item 0 current-projects "do-project?" = false [
      ;; ask patch to set proj-here false if project investor decided to not do project
      ask table:get item 0 current-projects "project-location" [
        set proj-here? false
      ]
      set new-project? false
      ;; wipe the project data from current-projects
      set current-projects remove-item 0 current-projects
    ]
    if new-project? = true and table:get item 0 current-projects "do-project?" = true [
      set cash (cash - table:get item 0 current-projects "project-cost")
      table:put item 0 current-projects "project-time-elapsed" 0
    ]
end

to core.update-or-complete-project
  foreach n-values length current-projects [i -> i] [ n ->
    let time-now table:get item n current-projects "project-time-elapsed"
    set time-now (time-now + 1)
    table:put item n current-projects "project-time-elapsed" time-now ;; can also be a reporter to get diff in time
  ]

  let to-delete (list)

  foreach n-values length current-projects [i -> i] [ n ->
    if table:get item n current-projects "project-time-elapsed" = table:get item n current-projects "project-timeframe" [
      set completed-projects (completed-projects + 1)
      set to-delete fput n to-delete
    ] ;; discrete event simulator
  ]
  foreach to-delete [ n ->
    update-stats n
    set current-projects remove-item n current-projects
  ]
end